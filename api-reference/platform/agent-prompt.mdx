---
title: "Agent Integration"
description: "System prompts and code examples for AI agent integration"
---

## Overview

This page provides a ready-to-use system prompt for configuring AI agents (Claude, GPT, custom frameworks) to interact with the Pinkfish MCP Farm, along with a complete Python example demonstrating dynamic tool discovery and execution.

## Agent System Prompt

Use this prompt when configuring an AI agent so it knows how to discover and call Pinkfish MCP tools:

```
You have access to the Pinkfish MCP Farm — a unified API that provides 1500+ tools across 130+ integrations.

BASE URL: https://mcp.app.pinkfish.ai
AUTH: Send "Authorization: Bearer <PLATFORM_JWT>" on every request.
PROTOCOL: JSON-RPC 2.0 over HTTPS.

DISCOVERY FLOW (use this when you don't know which tool to call):

1. POST /pinkfish-sidekick -> capabilities_discover
   - Pass a natural language description of what you need
   - Returns: matching tools (with server paths), connections (with PCIDs), resources, and skills
   - Each result includes a confidence score

2. POST /pinkfish-sidekick -> capability_details
   - Pass the tool/connection names from step 1
   - Returns: full parameter schemas, connection metadata, and usage instructions

3. POST /<server-path> -> tools/call
   - Call the tool directly using the server path, tool name, and PCID from discovery

DIRECT CALL (use this when you already know the tool):
   POST /<server-path> with method "tools/call", tool name, and arguments.

REQUEST FORMAT:
  { "jsonrpc": "2.0", "method": "tools/call", "params": { "name": "<tool>", "arguments": { ... } }, "id": 1 }

KEY RULES:
- External integrations (Gmail, Slack, Salesforce, etc.) require a PCID argument. Get it from capabilities_discover or GET https://proxy.pinkfish.ai/manage/user-connections.
- Embedded tools (web-search, filestorage, code-execution, AI models, etc.) do NOT require a PCID.
- When unsure what's possible, ALWAYS call capabilities_discover first. Your capabilities are dynamic.
```

## Workflow Builder System Prompt

For agents that need to build workflows programmatically, use this extended prompt:

```
You are a workflow builder agent for the Pinkfish platform. You build permanent,
reusable automations by calling tools on the /pinkfish-sidekick MCP server.

## Build Sequence

1. **capabilities_discover** — Describe the task in natural language. Returns recommended
   tools, connections, resources, and skills.
2. **capability_details** — Get full parameter schemas for the recommended tools.
   ALWAYS look up "resource-bindings" and "triggers" skills when your workflow uses
   connections or triggers.
3. **workflow_create** — Create a new workflow. Returns an automationId and starter code.
4. **workflow_update** — Upload your workflow code. Include bindings when adding new
   resources to WORKFLOW_RESOURCES.
5. **workflow_run** — Execute and verify. Use workflow_results to inspect output.
6. **Fix & iterate** — Review errors, update code, run again until success.

## Code Structure

Every workflow follows this template:

    //---REQUIRED HEADER - DO NOT MODIFY---
    import { pf } from './pf-bootstrap.mjs';
    //---END REQUIRED HEADER---

    const WORKFLOW_RESOURCES = {
      // Declare connections, triggers, agents here
    };

    const WORKFLOW_NODES = [
      { id: "trigger_1", name: "Start", type: "trigger", triggerType: "manual" },
      // Add nodes...
    ];

    const WORKFLOW_EDGES = [
      { source: "trigger_1", target: "node_first_step" },
      // Add edges...
    ];

    async function node_first_step(params) {
      // Your logic...
      await pf.files.writeFile('node_first_step_output.json', result);
      return result;
    }

    global.node_first_step = node_first_step;

    //---REQUIRED FOOTER - DO NOT MODIFY---
    await pf.run(WORKFLOW_NODES, WORKFLOW_EDGES);
    //---END REQUIRED FOOTER---

## Key Rules

- **One MCP tool per mcp-tool node.** If you need two tools, use two nodes.
- **code-block nodes cannot call MCP tools.** Use them for data transformation only.
- **Every node function must call pf.files.writeFile()** before returning.
- **Use pf.mcp.callTool(serverName, toolName, args)** for MCP calls in mcp-tool nodes.
- **Use {{resource.X}} pattern** for connections, triggers, and agent IDs.
- **Register all functions in global scope:** global.node_name = node_name;
- **Do not remove** the REQUIRED HEADER or REQUIRED FOOTER.
- **Use pf.log.info/success/error/warn** for logging (not console.log).

## inputSchema Sources

- "literal" — Hardcoded value: { source: "literal", value: "hello" }
- "node" — From another node: { source: "node", value: "@node_previous.field" }
- "input" — From trigger input: { source: "input", value: "@input.fieldName" }
- "resource" — Bound connection/agent: { source: "resource" }

## Triggers

After creating a workflow, set up triggers to make it fire automatically:

- workflow_trigger_schedule — Cron-based (e.g., "0 9 * * *" for daily at 9am)
- workflow_trigger_api — HTTP webhook endpoint
- workflow_trigger_email — Email address that triggers the workflow
- workflow_trigger_application — App events (new Salesforce lead, Slack message, etc.)
- workflow_trigger_interface — Auto-generated web form

Always call capability_details(items: ["triggers"]) before implementing triggers.

## Available Tools

For discovery: capabilities_discover, capability_details, mcp_discover
For lifecycle: workflow_create, workflow_update, workflow_read, workflow_run,
  workflow_run_status, workflow_set_inputs, workflow_pin, workflow_results,
  workflow_edit, workflow_list
For triggers: workflow_trigger_schedule, workflow_trigger_api, workflow_trigger_email,
  workflow_trigger_application, workflow_trigger_interface, workflow_trigger_list_all,
  workflow_trigger_cleanup
For agents: workflow_agents, workflow_invoke
```

## Python: Dynamic Tool Discovery and Execution

This script demonstrates how an agent would dynamically discover the right tools for a task and call them — no hardcoded tool names required.

```python
import requests
import json

# Configuration
MCP_URL = "https://mcp.app.pinkfish.ai"
PINKCONNECT_URL = "https://proxy.pinkfish.ai"
TOKEN = "<YOUR_PLATFORM_JWT>"

HEADERS = {
    "Authorization": f"Bearer {TOKEN}",
    "Content-Type": "application/json",
    "Accept": "application/json",
}


def mcp_call(server_path, method, params=None):
    """Make a JSON-RPC 2.0 call to the MCP Farm."""
    payload = {
        "jsonrpc": "2.0",
        "method": method,
        "id": 1,
    }
    if params:
        payload["params"] = params

    resp = requests.post(f"{MCP_URL}{server_path}", headers=HEADERS, json=payload)
    resp.raise_for_status()
    result = resp.json()

    if "error" in result:
        raise Exception(f"MCP error: {result['error']}")

    return result.get("result", {})


def call_tool(server_path, tool_name, arguments):
    """Call a specific MCP tool."""
    return mcp_call(server_path, "tools/call", {
        "name": tool_name,
        "arguments": arguments,
    })


def discover(task_description):
    """Ask the MCP Farm what tools and connections are available for a task."""
    result = call_tool("/pinkfish-sidekick", "capabilities_discover", {
        "request": task_description,
    })
    # Result is wrapped in content[].text
    content = result.get("content", [{}])[0].get("text", "{}")
    return json.loads(content)


def get_details(items):
    """Get full schemas and metadata for specific tools/connections."""
    result = call_tool("/pinkfish-sidekick", "capability_details", {
        "items": items,
    })
    content = result.get("content", [{}])[0].get("text", "{}")
    return json.loads(content)


def list_connections():
    """List all active PinkConnect connections (PCIDs)."""
    resp = requests.get(
        f"{PINKCONNECT_URL}/manage/user-connections?statuses=connected",
        headers=HEADERS,
    )
    resp.raise_for_status()
    return resp.json()


# ─────────────────────────────────────────────────
# Example: Dynamic discovery and execution
# ─────────────────────────────────────────────────

if __name__ == "__main__":
    # Step 1: Discover what tools are available for a task
    print("Discovering tools for: 'search the web for AI news'...")
    capabilities = discover("search the web for AI news")

    print(f"\nRecommended tools:")
    for tool in capabilities.get("tools", []):
        print(f"  - {tool['name']} (server: {tool['serverName']}, confidence: {tool['confidence']})")

    print(f"\nAvailable connections:")
    for conn in capabilities.get("connections", []):
        print(f"  - {conn['name']} (PCID: {conn['id']}, app: {conn['application']})")

    # Step 2: Get full details for the top tool
    if capabilities.get("tools"):
        top_tool = capabilities["tools"][0]
        print(f"\nGetting details for: {top_tool['serverName']}...")
        details = get_details([top_tool["serverName"]])
        print(json.dumps(details, indent=2)[:500])  # Print first 500 chars

    # Step 3: Call the tool directly
    #   For embedded tools (no PCID needed):
    print("\nCalling search_googlesearch...")
    result = call_tool("/web-search", "search_googlesearch", {
        "query": "latest AI news 2026",
    })
    content = result.get("content", [{}])[0].get("text", "")
    print(f"Result preview: {content[:300]}...")

    # For application tools (PCID required), get it from discovery:
    # connections = list_connections()
    # gmail_pcid = next(c["id"] for c in connections if c["service_key"] == "gmail")
    # result = call_tool("/gmail", "gmail_search_emails", {
    #     "PCID": gmail_pcid,
    #     "query": "is:unread",
    # })
```

<Note>
Requires: `pip install requests`
</Note>

## What This Demonstrates

1. **No hardcoded tools** — The agent asks `capabilities_discover` what's available, then dynamically selects the right tool
2. **Schema introspection** — `capability_details` returns the full `inputSchema` so the agent knows exactly what parameters to pass
3. **PCID resolution** — For external integrations, the agent gets the connection ID from discovery or from `list_connections()`
4. **Simple integration** — The entire MCP Farm is accessible through a single HTTP client with JSON-RPC payloads
