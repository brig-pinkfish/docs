#!/usr/bin/env npx tsx
/**
 * Application MCP Server Documentation Generator
 *
 * Generates .mdx documentation pages for production-enabled application (external)
 * MCP servers by reading tool definitions from the platform repo.
 *
 * Usage (run from platform/servers/agentic/mcp/ for TypeScript path resolution):
 *   cd ../platform/servers/agentic/mcp
 *   npx tsx /path/to/docs/scripts/generate-application-mcp-docs.ts                  # Generate all
 *   npx tsx /path/to/docs/scripts/generate-application-mcp-docs.ts --server slack   # Generate one
 *
 * Prerequisites:
 *   - The platform repo must be cloned alongside the docs repo at ../platform
 *   - Node.js and npx/tsx must be available
 *   - Must be run from platform/servers/agentic/mcp/ directory (for @pinkfishai/* path aliases)
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// ============================================================================
// Configuration
// ============================================================================

const DOCS_ROOT = path.resolve(__dirname, '..')
const PLATFORM_ROOT = path.resolve(DOCS_ROOT, '../platform')
const SERVERS_DIR = path.join(
  PLATFORM_ROOT,
  'servers/agentic/mcp/src/servers/external'
)
const OUTPUT_DIR = path.join(
  DOCS_ROOT,
  'api-reference/mcp-servers/application'
)
const DOCS_JSON_PATH = path.join(DOCS_ROOT, 'docs.json')

const GENERATED_HEADER = `{/* Auto-generated by scripts/generate-application-mcp-docs.ts — do not edit manually */}`

// ============================================================================
// Human-readable descriptions for application servers
// Overrides the terse descriptions from available-servers.ts (e.g. "Slack API" → better)
// ============================================================================

const DESCRIPTION_OVERRIDES: Record<string, string> = {
  'slack': 'Channels, messages, reactions, users, and workspace management',
  'gmail': 'Email send, read, search, and label management',
  'google-drive': 'File storage, folders, permissions, and sharing',
  'google-sheets': 'Spreadsheet read, write, and formatting',
  'google-calendar': 'Events, calendars, and attendees',
  'google-docs': 'Document creation and editing',
  'google-forms': 'Form creation and response management',
  'google-maps': 'Geocoding, directions, and places',
  'google-bigquery': 'SQL queries, datasets, and tables',
  'google-slides': 'Presentation creation and editing',
  'google-iam': 'Identity and access management',
  'google-task': 'Task lists and task management',
  'google-workspace-admin': 'User and group administration',
  'microsoft-outlook': 'Email, calendar, and contacts',
  'microsoft-excel': 'Workbook and worksheet operations',
  'microsoft-powerpoint': 'Presentation operations',
  'microsoft-powerbi': 'Reports, datasets, and dashboards',
  'microsoft-teams': 'Channels, messages, and meetings',
  'microsoft-word': 'Document operations',
  'microsoft-active-directory': 'Users, groups, and directory management',
  'onedrive': 'File storage and sharing',
  'sharepoint': 'Sites, lists, and document libraries',
  'dynamics-crm': 'Accounts, contacts, leads, and opportunities',
  'salesforce': 'Objects, queries, records, and reports',
  'salesforce-sandbox': 'Sandbox environment for development and testing',
  'hubspot': 'Contacts, deals, companies, and pipelines',
  'zoho': 'CRM records and modules',
  'zoom': 'Meetings, recordings, and participants',
  'docusign': 'Envelopes, signing, and templates',
  'zendesk': 'Tickets, users, and organizations',
  'servicenow': 'Incidents, requests, and workflows',
  'freshdesk': 'Tickets, contacts, and agents',
  'snowflake': 'SQL queries, warehouses, and databases',
  'databricks': 'Notebooks, jobs, and clusters',
  'tableau': 'Workbooks, views, and data sources',
  'airtable': 'Bases, tables, and records',
  'monday': 'Boards, items, and columns',
  'notion': 'Pages, databases, and blocks',
  'confluence': 'Spaces, pages, and content',
  'jira': 'Issues, projects, and boards',
  'jira-itsm': 'IT service management',
  'jira-forms': 'Form management',
  'linear': 'Issues, projects, and cycles',
  'asana': 'Tasks, projects, and workspaces',
  'smartsheet': 'Sheets, rows, and columns',
  'shopify': 'Products, orders, and customers',
  'stripe': 'Payments, subscriptions, and customers',
  'github': 'Repos, issues, and pull requests',
  'twilio': 'SMS, voice, and messaging',
  'openai': 'Chat completions, embeddings, and images',
  'anthropic': 'Claude models',
  'gemini': 'Google AI models',
  'deepgram': 'Speech-to-text and text-to-speech',
  'linkedin': 'Profile, posts, and connections',
  'linkedin-marketing': 'Ad campaigns and analytics',
  'sendgrid': 'Email campaigns and contacts',
  'dropbox': 'Files, folders, and sharing',
  'box': 'Files, folders, and collaborations',
  'amazon-s3': 'Buckets, objects, and presigned URLs',
  'azure-storage': 'Blobs, containers, and queues',
  'postgresql': 'SQL queries and schema management',
  'redis': 'Key-value operations',
  'figma': 'Design files and components',
  'gong': 'Revenue intelligence and call recordings',
  'fireflies': 'Meeting transcription',
  'greenhouse': 'Recruiting and hiring',
  'okta': 'Identity and access management',
  'kandji': 'Apple device management',
  'jamf': 'Apple device management',
  'sophos': 'Endpoint security',
  'airwatch': 'Enterprise mobility management',
  'snipeit': 'IT asset management',
  'hyperproof': 'Compliance management',
  'akeneo': 'Product information management',
  'responsiveio': 'RFP response management',
  'apify': 'Web scraping and automation',
  'brightdata': 'Web data collection',
  'polygon-io': 'Financial market data',
  'gamma': 'AI-powered presentation generation',
  'sftp-ftp': 'Secure file transfer (SFTP and FTP)',
  'faire': 'Wholesale marketplace',
  'iterable': 'Marketing analytics',
  'apollo': 'Prospecting and enrichment',
  'commercetools': 'Products, customers, orders, carts, and inventory',
  'mssql': 'Microsoft SQL Server queries and schema management',
  'mysql': 'MySQL database queries and schema management',
  'onenote': 'Notebooks, pages, and content management',
  'twitter': 'Tweets, users, timelines, and media',
  'quickbase': 'Applications, tables, records, and fields',
  'freshservice': 'IT service management tickets, assets, and agents',
  'kallidus-sapling': 'Employee records and department management',
  'sirv': 'Image CDN upload, management, and statistics',
  'talkdesk': 'Contact center agents, calls, queues, and recordings',
}

function getDescription(serverName: string, rawDescription: string): string {
  return DESCRIPTION_OVERRIDES[serverName] || rawDescription
}

// ============================================================================
// Zod-to-JSON-Schema converter (adapted from platform/servers/agentic/mcp/src/services/server-selector.ts)
// ============================================================================

function zodToJsonSchema(zodSchema: any): any {
  if (!zodSchema || !zodSchema._def) {
    return { type: 'any' }
  }

  const typeName = zodSchema._def.typeName
  const description =
    zodSchema._def.description || zodSchema.description || ''

  if (typeName === 'ZodString') {
    const result: any = { type: 'string' }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodNumber') {
    const result: any = { type: 'number' }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodBoolean') {
    const result: any = { type: 'boolean' }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodArray') {
    const itemSchema = zodToJsonSchema(zodSchema._def.type)
    const result: any = { type: 'array', items: itemSchema }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodObject') {
    const shape = zodSchema._def.shape()
    const properties: Record<string, any> = {}
    for (const [key, value] of Object.entries(shape)) {
      properties[key] = zodToJsonSchema(value)
    }
    const result: any = { type: 'object', properties }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodEnum') {
    const result: any = { type: 'string', enum: zodSchema._def.values }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodOptional') {
    const innerSchema = zodToJsonSchema(zodSchema._def.innerType)
    if (description && !innerSchema.description) {
      return { ...innerSchema, description }
    }
    return innerSchema
  }

  if (typeName === 'ZodNullable') {
    const innerSchema = zodToJsonSchema(zodSchema._def.innerType)
    const result = { ...innerSchema, nullable: true }
    if (description && !innerSchema.description) {
      result.description = description
    }
    return result
  }

  if (typeName === 'ZodDefault') {
    const innerSchema = zodToJsonSchema(zodSchema._def.innerType)
    const result = { ...innerSchema, default: zodSchema._def.defaultValue() }
    if (description && !innerSchema.description) {
      result.description = description
    }
    return result
  }

  if (typeName === 'ZodUnion') {
    const options = zodSchema._def.options as unknown[]
    if (options && options.length > 0) {
      const oneOf = options.map((option: any) => zodToJsonSchema(option))
      const result: any = { oneOf }
      if (description) result.description = description
      return result
    }
  }

  if (typeName === 'ZodRecord') {
    const result: any = { type: 'object', additionalProperties: true }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodNativeEnum') {
    const result: any = {
      type: 'string',
      enum: Object.values(zodSchema._def.values)
    }
    if (description) result.description = description
    return result
  }

  if (typeName === 'ZodLiteral') {
    const result: any = { type: typeof zodSchema._def.value, const: zodSchema._def.value }
    if (description) result.description = description
    return result
  }

  return {
    type: typeName?.replace('Zod', '').toLowerCase() || 'any',
    ...(description ? { description } : {})
  }
}

// ============================================================================
// Parameter extraction from Zod schemas
// ============================================================================

interface ParamInfo {
  name: string
  type: string
  required: boolean
  defaultValue: string
  description: string
}

function getZodTypeName(zodSchema: any): string {
  if (!zodSchema || !zodSchema._def) return 'any'
  const typeName = zodSchema._def.typeName

  if (typeName === 'ZodOptional') return getZodTypeName(zodSchema._def.innerType)
  if (typeName === 'ZodNullable') return getZodTypeName(zodSchema._def.innerType)
  if (typeName === 'ZodDefault') return getZodTypeName(zodSchema._def.innerType)
  if (typeName === 'ZodString') return 'string'
  if (typeName === 'ZodNumber') return 'number'
  if (typeName === 'ZodBoolean') return 'boolean'
  if (typeName === 'ZodArray') return `${getZodTypeName(zodSchema._def.type)}[]`
  if (typeName === 'ZodObject') return 'object'
  if (typeName === 'ZodEnum') return 'string'
  if (typeName === 'ZodRecord') return 'object'
  if (typeName === 'ZodNativeEnum') return 'string'
  if (typeName === 'ZodLiteral') return typeof zodSchema._def.value
  if (typeName === 'ZodUnion') return 'string'
  return 'any'
}

function isOptional(zodSchema: any): boolean {
  if (!zodSchema || !zodSchema._def) return false
  const typeName = zodSchema._def.typeName
  if (typeName === 'ZodOptional') return true
  if (typeName === 'ZodDefault') return true // has a default, so effectively optional
  if (typeName === 'ZodNullable') return isOptional(zodSchema._def.innerType)
  return false
}

function getDefault(zodSchema: any): string {
  if (!zodSchema || !zodSchema._def) return '—'
  const typeName = zodSchema._def.typeName
  if (typeName === 'ZodDefault') {
    const val = zodSchema._def.defaultValue()
    if (val === undefined || val === null) return '—'
    if (typeof val === 'string') return `\`"${val}"\``
    return `\`${JSON.stringify(val)}\``
  }
  if (typeName === 'ZodOptional') return '—'
  if (typeName === 'ZodNullable') return getDefault(zodSchema._def.innerType)
  return '—'
}

function getZodDescription(zodSchema: any): string {
  if (!zodSchema || !zodSchema._def) return ''
  // Walk through wrappers to find the description
  const desc = zodSchema._def.description || zodSchema.description || ''
  if (desc) return desc
  const typeName = zodSchema._def.typeName
  if (
    typeName === 'ZodOptional' ||
    typeName === 'ZodDefault' ||
    typeName === 'ZodNullable'
  ) {
    return getZodDescription(zodSchema._def.innerType)
  }
  return ''
}

function extractParams(paramsSchema: Record<string, any>): ParamInfo[] {
  const params: ParamInfo[] = []
  for (const [name, schema] of Object.entries(paramsSchema)) {
    if (name === 'PCID') continue // Skip PCID — documented in overview
    params.push({
      name,
      type: getZodTypeName(schema),
      required: !isOptional(schema),
      defaultValue: getDefault(schema),
      description: getZodDescription(schema)
    })
  }
  return params
}

// ============================================================================
// MDX generation
// ============================================================================

function escapeMarkdown(str: string): string {
  // Escape characters that MDX parses as JSX:
  //   { } → HTML entities (JSX expressions)
  //   < > → HTML entities (prevents JSX tag parsing, e.g. <Drive>, <tenant>)
  //   | → backslash escape (markdown table delimiter)
  return str
    .replace(/\|/g, '\\|')
    .replace(/\{/g, '&#123;')
    .replace(/\}/g, '&#125;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}

function generateToolSection(tool: any): string {
  const params = extractParams(tool.paramsSchema || {})

  // Build inputSchema JSON from paramsSchema
  const inputSchemaObj: any = { type: 'object', properties: {} }
  const required: string[] = []
  for (const [name, schema] of Object.entries(tool.paramsSchema || {})) {
    inputSchemaObj.properties[name] = zodToJsonSchema(schema)
    if (!isOptional(schema)) {
      required.push(name)
    }
  }
  if (required.length > 0) {
    inputSchemaObj.required = required
  }

  let md = `## ${tool.name}\n\n`
  md += `${escapeMarkdown(tool.description)}\n\n`

  // Parameters table
  if (params.length > 0) {
    md += `**Parameters:**\n\n`
    md += `| Parameter | Type | Required | Default | Description |\n`
    md += `| --- | --- | --- | --- | --- |\n`
    for (const p of params) {
      md += `| \`${p.name}\` | ${p.type} | ${p.required ? 'Yes' : 'No'} | ${p.defaultValue} | ${escapeMarkdown(p.description)} |\n`
    }
    md += '\n'
  }

  // Expandable inputSchema
  md += `<Expandable title="inputSchema">\n\n`
  md += '```json\n'
  md += JSON.stringify(inputSchemaObj, null, 2) + '\n'
  md += '```\n\n'
  md += `</Expandable>\n`

  return md
}

function generateServerPage(
  serverName: string,
  rawDescription: string,
  tools: any[]
): string {
  const description = getDescription(serverName, rawDescription)

  let md = `---\n`
  md += `title: "${serverName}"\n`
  md += `sidebarTitle: "${serverName}"\n`
  md += `description: "${description.replace(/"/g, '\\"')}"\n`
  md += `---\n\n`
  md += `${GENERATED_HEADER}\n\n`
  md += `**Server path:** \`/${serverName}\` | **Type:** Application | **PCID required:** Yes\n\n`
  md += `${escapeMarkdown(description)}\n\n`

  // Tools table
  md += `## Tools\n\n`
  md += `| Tool | Description |\n`
  md += `| --- | --- |\n`
  for (const tool of tools) {
    md += `| [\`${tool.name}\`](#${tool.name}) | ${escapeMarkdown(tool.description)} |\n`
  }
  md += '\n---\n\n'

  // Individual tool sections
  for (let i = 0; i < tools.length; i++) {
    md += generateToolSection(tools[i])
    if (i < tools.length - 1) {
      md += '\n---\n\n'
    }
  }

  return md
}

// ============================================================================
// Server registry loading
// ============================================================================

interface ServerEntry {
  name: string
  description: string
  path: string
  embedded: boolean
  productionEnabled?: boolean
  tools: any[]
}

async function loadAvailableServers(): Promise<ServerEntry[]> {
  // Dynamically import available-servers.ts from the platform repo
  // This requires running with tsx which handles TypeScript + path aliases
  const availableServersPath = path.join(
    PLATFORM_ROOT,
    'servers/agentic/mcp/src/servers/available-servers.ts'
  )

  try {
    const mod = await import(availableServersPath)
    return mod.AVAILABLE_SERVERS as ServerEntry[]
  } catch (e) {
    // If direct import fails (path aliases), fall back to loading tool files individually
    console.error(
      'Could not import available-servers.ts directly. Falling back to file-based loading.'
    )
    console.error(e)
    throw e
  }
}

async function loadToolsForServer(
  serverName: string
): Promise<any[] | null> {
  const toolsPath = path.join(SERVERS_DIR, serverName, 'tools.ts')
  if (!fs.existsSync(toolsPath)) {
    console.warn(`  Warning: No tools.ts found for ${serverName}`)
    return null
  }
  try {
    const mod = await import(toolsPath)
    return mod.TOOLS || null
  } catch (e) {
    console.warn(`  Warning: Failed to load tools for ${serverName}: ${e}`)
    return null
  }
}

// ============================================================================
// docs.json update
// ============================================================================

function updateDocsJson(serverNames: string[], singleServer?: string): void {
  const docsJson = JSON.parse(fs.readFileSync(DOCS_JSON_PATH, 'utf-8'))

  // Find the "Application MCP Servers" group in the navigation
  let appGroup: any = null
  function findGroup(obj: any): boolean {
    if (Array.isArray(obj)) {
      for (const item of obj) {
        if (findGroup(item)) return true
      }
    } else if (obj && typeof obj === 'object') {
      if (obj.group === 'Application MCP Servers') {
        appGroup = obj
        return true
      }
      for (const value of Object.values(obj)) {
        if (findGroup(value)) return true
      }
    }
    return false
  }
  findGroup(docsJson)

  if (!appGroup) {
    console.error('Could not find "Application MCP Servers" group in docs.json')
    process.exit(1)
  }

  if (singleServer) {
    // Add single server page if not already present, maintaining alphabetical order
    const pagePath = `api-reference/mcp-servers/application/${singleServer}`
    const existingPages: string[] = appGroup.pages || []
    if (!existingPages.includes(pagePath)) {
      // Insert in alphabetical order after overview
      const serverPages = existingPages.filter(p => p !== 'api-reference/mcp-servers/application/overview')
      serverPages.push(pagePath)
      serverPages.sort()
      appGroup.pages = ['api-reference/mcp-servers/application/overview', ...serverPages]
    }
  } else {
    // Replace all pages with overview + generated pages
    const pages = ['api-reference/mcp-servers/application/overview']
    for (const name of serverNames.sort()) {
      pages.push(`api-reference/mcp-servers/application/${name}`)
    }
    appGroup.pages = pages
  }

  fs.writeFileSync(DOCS_JSON_PATH, JSON.stringify(docsJson, null, 2) + '\n')
}

// ============================================================================
// Main
// ============================================================================

async function main(): Promise<void> {
  const args = process.argv.slice(2)
  const serverFlagIdx = args.indexOf('--server')
  const singleServer =
    serverFlagIdx !== -1 ? args[serverFlagIdx + 1] : undefined

  console.log('=== Application MCP Server Documentation Generator ===\n')

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true })
  }

  // Load server registry
  let servers: ServerEntry[]
  try {
    servers = await loadAvailableServers()
  } catch {
    // Fallback: scan external server directories and load tools directly
    console.log('Falling back to directory-based server discovery...\n')
    servers = await fallbackLoadServers()
  }

  // Filter to external, production-enabled servers
  const externalServers = servers.filter(
    (s) => s.embedded === false && s.productionEnabled !== false
  )

  console.log(
    `Found ${externalServers.length} production-enabled application servers\n`
  )

  // Filter to single server if requested
  const toGenerate = singleServer
    ? externalServers.filter((s) => s.name === singleServer)
    : externalServers

  if (singleServer && toGenerate.length === 0) {
    console.error(`Server "${singleServer}" not found or not production-enabled.`)
    console.error(
      'Available servers:',
      externalServers.map((s) => s.name).join(', ')
    )
    process.exit(1)
  }

  let totalTools = 0
  const generatedNames: string[] = []

  for (const server of toGenerate) {
    const tools = server.tools || (await loadToolsForServer(server.name))
    if (!tools || tools.length === 0) {
      console.warn(`  Skipping ${server.name}: no tools found`)
      continue
    }

    console.log(
      `  Generating ${server.name}.mdx (${tools.length} tools)...`
    )

    const mdx = generateServerPage(server.name, server.description, tools)
    const outputPath = path.join(OUTPUT_DIR, `${server.name}.mdx`)
    fs.writeFileSync(outputPath, mdx)

    totalTools += tools.length
    generatedNames.push(server.name)
  }

  // Update docs.json
  if (generatedNames.length > 0) {
    if (singleServer) {
      updateDocsJson(generatedNames, singleServer)
      console.log(`\nUpdated docs.json with ${singleServer} page`)
    } else {
      updateDocsJson(generatedNames)
      console.log(`\nUpdated docs.json with ${generatedNames.length} pages`)
    }
  }

  console.log(`\n=== Done ===`)
  console.log(`  Servers: ${generatedNames.length}`)
  console.log(`  Tools:   ${totalTools}`)
  console.log(`  Output:  ${OUTPUT_DIR}/`)
}

// Fallback: scan directories if available-servers.ts can't be imported
async function fallbackLoadServers(): Promise<ServerEntry[]> {
  // Read available-servers.ts as text and extract server configs
  const availableServersPath = path.join(
    PLATFORM_ROOT,
    'servers/agentic/mcp/src/servers/available-servers.ts'
  )
  const source = fs.readFileSync(availableServersPath, 'utf-8')

  // Find all external server directories
  const dirs = fs.readdirSync(SERVERS_DIR, { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .map((d) => d.name)

  const servers: ServerEntry[] = []

  for (const dirName of dirs) {
    // Extract server config from the source text
    const nameRegex = new RegExp(
      `name:\\s*'${dirName}'[\\s\\S]*?embedded:\\s*(true|false)`,
      'g'
    )
    const match = nameRegex.exec(source)
    if (!match || match[1] === 'true') continue // skip embedded or not found

    // Extract description
    const descRegex = new RegExp(
      `name:\\s*'${dirName}'[\\s\\S]*?description:[\\s\\S]*?['"\`]([^'"\`]+)['"\`]`
    )
    const descMatch = descRegex.exec(source)
    const description = descMatch ? descMatch[1] : `${dirName} API`

    // Check productionEnabled
    const prodRegex = new RegExp(
      `name:\\s*'${dirName}'[\\s\\S]*?productionEnabled:\\s*(true|false)`
    )
    const prodMatch = prodRegex.exec(source)
    const productionEnabled = prodMatch ? prodMatch[1] !== 'false' : true

    // Load tools
    const tools = await loadToolsForServer(dirName)
    if (!tools) continue

    servers.push({
      name: dirName,
      description,
      path: `/${dirName}`,
      embedded: false,
      productionEnabled,
      tools
    })
  }

  return servers
}

main().catch((e) => {
  console.error('Fatal error:', e)
  process.exit(1)
})
