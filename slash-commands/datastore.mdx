---
title: "Datastore Guide"
description: "Learn how to use the datastore slash command to interact with NoSQL data storage"
---

## What can you do with it?

Store, retrieve, update, and search data in a NoSQL datastore. Perfect for managing structured data with key-value pairs, metadata, and optional sorting capabilities.

## How to use it?

### Basic Command Structure
```
/datastore
action: create, read, update, delete, or search
key: unique identifier for your data
content: the data to store
```

### Parameters
- **action**: Operation to perform (create, read, update, delete, search)
- **key**: Unique identifier for the item (required for most operations)
- **content**: Data to store (required for create/update)
- **collection** (optional): Collection ID for data isolation
- **sort field** (optional): Secondary sorting field
- **metadata** (optional): Additional custom attributes
- **search query** (optional): Text to search for

### Response Format
Returns stored items with their IDs, timestamps, and content. Search operations include relevance scores and matched snippets.

## Examples

### Basic Usage
Store simple data:
```
/datastore
action: create
key: user123
content: {"name": "John Doe", "email": "john@example.com"}
```

### Advanced Usage
Search with filters:
```
/datastore
action: search
search query: customer feedback
field: content
type: fuzzy
metadata.category: reviews
```

### Specific Use Case
Update with triggers:
```
/datastore
action: update
key: order456
content: {"status": "shipped", "tracking": "ABC123"}
trigger urls: {"https://webhook.site/notify": "api-key-123"}
```

### Notes
- Items are uniquely identified by key + sortField combination
- Use itemId for direct access to specific items
- Search supports fuzzy, exact, and prefix matching
- Triggers can notify external URLs on data changes
- URL-encode keys and sortFields in API calls
