---
title: "Unstructured Datastore"
description: "Flexible JSON storage for dynamic data without schema requirements"
---

## Overview

Unstructured Datastores provide flexible NoSQL storage for any data type without schema requirements. Store strings, numbers, objects, or arrays - perfect for dynamic content, logs, and API responses.

## Creating a Datastore

### API Endpoint

```
POST /datacollection/
```

### Request Body

```json
{
  "name": "My Datastore",
  "description": "Optional description",
  "type": "datastore",
  "createdBy": "your-provider-id",
  "createdByName": "Your Name",
  "triggerUrls": []
}
```

**Parameters:**
- `name` (required) - Display name for your datastore
- `description` (optional) - Description of what this datastore contains
- `type` (required) - Must be "datastore" for unstructured datastores
- `createdBy` (required) - Your provider ID
- `createdByName` (required) - Your display name
- `triggerUrls` (optional) - Collection-level event triggers
- `isStructured` (optional) - Must be `false` or omitted for unstructured datastores

**Response:**
```json
{
  "id": "abc123-collection-id",
  "message": "Data collection created successfully"
}
```

**Note:** By default, collections are created as unstructured unless `isStructured: true` is explicitly set.

## Key Features

- **No schema required** - store any JSON structure
- **Flexible content** - strings, numbers, objects, arrays
- **Fast search** - fuzzy, exact, and prefix matching
- **Event triggers** - automate workflows on data changes
- **Batch operations** - create up to 500 items at once
- **Multiple access methods** - by key, key+sortField, or itemId

## Basic Command Structure

```
/selected-datastore [action] [parameters]
```

## CRUD Operations

### Create Item

```
/selected-datastore create item with:
key: user-settings
sortField: theme-preferences
content: {"theme": "dark", "language": "en", "notifications": true}
metadata: {"version": "1.0", "lastSync": "2024-01-15"}
```

**Parameters:**
- `key` (required) - Primary identifier
- `content` (required) - Any JSON structure
- `sortField` (optional) - Auto-generated if not provided
- `metadata` (optional) - Custom tracking attributes
- `triggerUrls` (optional) - Event-driven webhooks

### Batch Create

Create up to 500 items efficiently:

```
/selected-datastore create batch with items:
[
  {
    "key": "logs",
    "sortField": "2024-01-15-10:30",
    "content": {"level": "info", "message": "Server started"},
    "metadata": {"service": "api"}
  },
  {
    "key": "logs",
    "sortField": "2024-01-15-10:31",
    "content": {"level": "warn", "message": "High memory usage"},
    "metadata": {"service": "api"}
  }
]
```

**Best practices:**
- Keep batches under 100 items for best performance
- Larger batches (up to 500) may cause gateway timeouts
- Each item can have different structure

### Read Items

**By item ID (recommended):**
```
/selected-datastore get item with itemId: abc123def456
```

**By key (returns all items with that key):**
```
/selected-datastore get items with key: user-settings
```

**By key + sortField (returns specific item):**
```
/selected-datastore get item with:
key: user-settings
sortField: theme-preferences
```

### List Items

```
/selected-datastore list items with:
limit: 50
orderedBy: createdAt:desc
format: light
```

**Parameters:**
- `limit` - Max results (default: 50, max: 1000)
- `orderedBy` - Sort by createdAt or updatedAt (e.g., "createdAt:desc")
- `format` - Set to "light" for minimal data (excludes content)

### Update Item

**Full Replace (PUT) - Recommended for unstructured datastores**

Replaces the entire content field:

```
PUT /memory/items/{itemId}?collectionId=xxx
```

```json
{
  "content": "new string value"
}
```

Or with object content:

```json
{
  "content": {"theme": "light", "notifications": false},
  "metadata": {"version": "1.1"}
}
```

Content is completely replaced. Works with any data type (string, number, object, array).

**Partial Update (PATCH)**

Only for object content - merges with existing:

```
PATCH /memory/items/{itemId}?collectionId=xxx
```

```json
{
  "content": {"theme": "light"}
}
```

Existing fields in content object are preserved. Only works with object content (not strings, numbers, or arrays).

### Delete Item

**By itemId (recommended):**
```
/selected-datastore delete item with itemId: abc123def456
```

**By key + sortField:**
```
/selected-datastore delete item with:
key: user-settings
sortField: theme-preferences
```

**By key (deletes all items with that key):**
```
/selected-datastore delete items with key: user-settings
```

## Search

Advanced search with fuzzy matching:

```
/selected-datastore search with:
q: customer feedback
field: content
type: fuzzy
threshold: 0.3
limit: 50
```

**Parameters:**
- `q` (required) - Search query
- `field` - Where to search: "all" (default), "content", "key", "sortField"
- `type` - Match type: "fuzzy" (default), "exact", "prefix"
- `threshold` - Fuzzy sensitivity (0.0 strict to 1.0 lenient, default 0.3)
- `limit` - Max results (default: 50, max: 1000)
- `compiled` - Output as plain text (true) or JSON with snippets (false)

**Response with snippets:**
```json
{
  "results": [
    {
      "docId": "abc123",
      "fieldMatched": "content",
      "matchedSnippet": "...customer **feedback** on the new...",
      "score": 0.84,
      "relevance": "high"
    }
  ]
}
```

## Key and Sort Field Patterns

The combination of `key` + `sortField` must be unique within a collection.

### Pattern 1: Single Key (Auto-generated Sort)

```
key: meeting-notes
```

Good for: Quick storage when uniqueness isn't critical

### Pattern 2: Key + Date Sort

```
key: meeting-notes
sortField: 2024-03-15
```

Good for: Time-series data, daily logs

### Pattern 3: Key + Email Sort

```
key: employee-reviews
sortField: jane.smith@company.com
```

Good for: Per-user data

### Pattern 4: Key + Category Sort

```
key: inventory
sortField: electronics-001
```

Good for: Categorized items with unique IDs

## Event Triggers

Automatically start workflows when data changes in your unstructured datastore. Triggers are **collection-level only** for unstructured datastores.

**Supported events:**
- **onCreate** - New items added
- **onEdit** - Existing items modified
- **onDelete** - Items removed

**Note:** Item-level triggers are not available for unstructured datastores. Use collection-level triggers via the collection management UI.

For complete documentation on setting up triggers, payload formats, rate limiting, and best practices, see the [Event Triggers guide](/essentials/event-triggers).

## Common Use Cases

- Application logs and event tracking
- API response caching
- Configuration and settings storage
- Dynamic content management
- Queue systems and task processing
- Session data storage
- Temporary data and cache
- Flexible data structures that change over time

## Best Practices

**Key & Sort Field:**
- Use descriptive keys that group related items
- Use sortField for uniqueness within a group
- itemId is most efficient for direct access

**Content Structure:**
- Keep content structure consistent within a collection for easier querying
- Use metadata for cross-cutting concerns (tags, timestamps, status)

**Triggers:**
- Use collection-level for system monitoring
- Use item-level for specific business logic
- Set `triggerChanges: false` to avoid recursive triggers

**Performance:**
- Use batch operations for multiple creates
- Use format: "light" when you only need metadata
- Set appropriate limits to reduce payload size

## Notes

- No schema validation - you can store any JSON structure
- Items uniquely identified by key + sortField combination
- Auto-generated sortField if not specified
- Search supports fuzzy matching for flexible queries
- PUT replaces entire content (use for strings, numbers, arrays, or full object replacement)
- PATCH merges content (only for object content, preserves unspecified fields)
- Collections can hold different content structures per item

